\chapter{Search}


\section{Introduction}

\section{Binary Search}
Variants:
\begin{enumerate}
\item bisect\_left
\item bisect\_right
\item get the idx equal or just lower 
\item get the idx equal or just higher 
\end{enumerate}
Binary search, get the idx equal or just lower, which is a very standard binary search:
\begin{python}
def bisect(self, A, t):
    lo = 0
    hi = len(A)
    while lo < hi:
        mid = (lo+hi)/2
        if A[mid] == t:
            return mid
        elif A[mid] < t:
            lo = mid+1
        else:
            hi = mid
    return lo-1
\end{python}

\section{Looping Root}
Iterate the list and make the current element as the root, evaluate the left part and the right part and combine the results (i.e. looping + divide \& conquer). 

\rih{Different ways to add parentheses.} Iterate the operators, divide and conquer left parts and right parts and then combine result:
\begin{python}
def dfs_eval(self, nums, ops):
    ret = []
    if not ops:
        assert len(nums) == 1
        return nums

    for i, op in enumerate(ops):
        left_vals = self.dfs_eval(nums[:i+1], ops[:i])
        right_vals = self.dfs_eval(nums[i+1:], ops[i+1:])
        for l in left_vals:
            for r in right_vals:
                ret.append(self._eval(l, r, op))

    return ret
\end{python}

