\chapter{Graph}


\section{Topological Sorting}
For a graph $G=\{V, E\}$, $ A \rightarrow B $, then $A$ is before $B$ in the ordered list. 
\subsection{Algorithm}
General algorithm and notice.\\
 
dfs:
\begin{enumerate}
\item \textbf{Dfs neighbors first}. If the neighbors of current node is  $\neg$visited, then dfs the neighbors
\item \textbf{Dfs current node}. After visiting all the neighbors, then visit the current node and push it to the result queue.
\item \textbf{Reverse}. Reverse the result queue. 
\end{enumerate}

Notice:
\begin{enumerate}
\item Need to \textbf{reverse} the result queue, since the neighbors (successors) are visited first. 
\item Need to \textbf{detect cycle}; thus the dfs need to construct result queue and detect cycle simultaneously, by using two sets: $visited$ and $marked$. 
\end{enumerate}
\begin{figure}[hbtp]
\centering
\subfloat{\includegraphics[scale=.60]{uf}}
\caption{Weighted quick-union traces}
\label{fig:union_find}
\end{figure}
\begin{python}
def topological_sort(self, V):
    visited = set()
    marked = set()
    ret = []

    for k in V.keys():
        if k not in visited:
            if not self.dfs(V, k, visited, marked, ret):
                return []  # contains cycle 

    ret.reverse()
    return ret

def dfs(self, V, k, visited, marked, ret):
    if k in marked:
        return False

    marked.add(k)
    for neighbor in V[k]:
        if neighbor not in visited:
            if not self.dfs(V, neighbor, visited, marked, ret):
                return False

    marked.remove(k)
    visited.add(k)
    ret.append(k)
    return True
\end{python}

\subsection{Applications}
\begin{enumerate}
\item Course scheduling problem with pre-requisite. 
\end{enumerate}

\section{Union Find}
\subsection{Algorithm}
Weighted union find with path compression: 
\begin{enumerate}
\item An array to store each item's predecessor \textbf{pi}. 
\item Merge the tree according to the \textbf{size} to maintain balance. 
\end{enumerate}
\begin{python}
class UnionFind(object):
    """
    Weighted Union Find with path compression
    """
    def __init__(self):
        self.pi = {}  # item -> pi
        self.sz = {}  # root -> size

    def add(self, item):
        if item not in self.pi:
            self.pi[item] = item
            self.sz[item] = 1

    def union(self, a, b):
        pi1 = self._pi(a)
        pi2 = self._pi(b)

        if pi1 != pi2:
            if self.sz[pi1] > self.sz[pi2]:
                pi1, pi2 = pi2, pi1

            self.pi[pi1] = pi2
            self.sz[pi2] += self.sz[pi1]
            del self.sz[pi1]

    def _pi(self, item):
        pi = self.pi[item]
        if item != pi:
            self.pi[item] = self._pi(pi)

        return self.pi[item]

    def compress(self):
        for item in self.pi.keys():
            self.pi[item] = self._pi(item)

    def count(self):
        return len(self.sz)  # only root nodes have size
\end{python}

